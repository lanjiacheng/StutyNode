一、一个情况：
在子类构造对象时，发现，访问子类构造函数时，父类构造函数也运行了
原因：在子类构造函数中第一行有一个默认的隐式语句：super（）；
super就是父类的构造函数，父类的构造函数不能被覆盖

二、一个实例：
class Fu
{
	Fu()
	{
		System.out.println("fu run");
	}
}
class Zi
{
	Zi()
	{
		//this();此处如果出现这个语句，此构造函数中将不会再有super（）语句
			而且说明一点：构造函数中用到本类其他构造函数时可以通过this
			来调用，并且this语句必须在第一行（第一行被this占用，那么super（）不可能出现）
		//super();	//此语句默认隐式有，但是可以显示使用，显式使用可以
					通过传递参数的不同来调用不同的父类构造函数
		System.out.println("zi run");
	}
}
说明：当用new语句创建一个zi类对象的时候，将会打印如下：
fu run
zi run
}

三、几点说明：
1.为什么子类实例化的时候要访问父类当中的构造函数呢？
那是因为子类继承了父类，获取到了父类的内容（属性），所以在使用父类之前，
先看看父类是如何对自己的内容进行初始化的。
所以子类对象在构造对象时，必须访问父类中的构造函数
为了完成这个必须的动作，就在父类的构造函数中加入super（）语句

2.如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要
调用父类中的哪个构造函数

3.注意：
super语句必须要定义在子类构造函数当中的第一行
因为父类的初始化动作必须先完成

4.如果子类构造函数调用了this（）时，该构造函数将不会再有super（）语句，因为
this和super语句只能放在第一行
但是可以肯定的是，子类当中一定会有其他构造函数中有super（）函数	

5.当在创建子类对象时，子类构造函数调用到父类构造函数，且父类构造函数的this所属的值是子类
的对象，如果父类构造函数中又调用了一个
函数，且该函数在子类和父类当中都存在，且一模一样，那么调用的应该是子类中的同名的函数，
因为在创建对象时产生了覆盖，父类中同名函数被覆盖

6.当创建子类对象时，子类对象会立刻生成，并且对象中每一个成员都有默认初始化值，然后才调
用构造函数进行对象的初始化，子类构造函数又会调用父类构造函数对父类的成员进行初始化，父类
初始化完毕，才会轮到子类构造函数对子类成员进行初始化，所以也就是说，父类构造函数执行的时候，子类成员变量的值都是默认初始化的值！

7.
class Fu
{
	Fu()
	{
		System.out.println("fu run");
	}
}
class Zi
{
	int num = 8;	//此处注意：num并非对象一创建就有值8的，其实在构造函数执行完成
			//之前，num的值还是默认初始化的值（0），num的显示初始化是在构造函			//数中完成的（即使构造函数中没有显示出现给num赋值）
	Zi()
	{
		super();
		//通过syper初始化父类内容时，子类成员并未显示初始化，等super（）给父类
		//初始化完毕以后，才进行子类成员的显示初始化
		System.out.println("zi ...."+num);
		return;
	}
}
